# 操作系统复习课

3.9 4.8 4.8 5.8 5.9 6.7 跳过

单双缓冲/进程

批处理 内核类型 进程高中低调度

---

## 进程管理

死锁的几个条件 中断 syscall

进程跟程序的区别 几种状态 p53 pcb的含义 控制典型事件

> [!NOTE]
>
> :bulb:进程同步
>
> 伪代码：信号量 互斥 同步 进程函数 临界区划分
>
> :bulb:进程调度 先来先服务FCFS 短作业优先SJF HRRF……
>
> 

理解3.6

> [!NOTE]
>
> 3.7 
>
> :bulb:银行家算法  判断安全
>
> 几种必要条件
>
> 避免死锁
>
> 资源分配图简化看死锁

理解3.8

---

## 存储器管理

### :books:连续存储：根据作业需求空间大小 分配一段连续内存

理解4.2 可变分区分配 几种算法

- 首次适应 塞进最早够用的--空闲分区：地址递增的链表
- 最佳适应 塞进大小最近的--空闲分区：大小递增的链表
- 最坏适应 塞进最大的--空闲分区：大小递减的链表

分区回收：邻近则合并，否则独立

伙伴系统（平衡效率与空间消耗）：m个空闲分区链表，大小为2的指数

### :books:页式存储：将逻辑和物理空间切割成定长，一一映射并建立目录表

> [!NOTE] 
>
> :bulb:4.3 
>
> 地址块转换 多级页表 
>
> 逻辑地址结构:共xx位，前xx位是页号
>
> 逻辑地址（页号）--页表--物理地址（块号）
>
> 页表首地址和长度存在PCB中
>
> 有无快表--是否命中-- 计算时间差

###  :books:段式存储：按功能分区

4.4 段的概念 段号与段内地址 段表 越界

按逻辑功能 分不定长的段：代码段、数据段、栈

由功能设定不同权限，便于实现共享与保护，便于实现动态链接

### :books:段页式

对用户程序分段，对内存分页

地址结构：段号--段内页号--页内偏移

进程运行时：查段表-查页表-得到物理地址

理解4.5

### :books:虚拟存储

时空局部性 多次性 置换性 虚拟性

需要时再调入内存，置换掉原则上最无用的页面，随用随取从而逻辑上扩大了可执行空间

请求分页：增加访问位、存在位、修改位

> [!NOTE]
>
> 4.6 
>
> :bulb:页面置换算法 OPT FIFO LRU LFU CLOCK
>
> - FIFO 先进先出
> - OPT 最佳置换 --最长时间无用（理想最优
> - LRU 最近最久未使用--根据经验预测将来--设置引用位并计时/用栈
> - :bulb:clock：最近未使用
> - LFU 最近最少使用

---

## 设备管理

IO控制 分类

- 块设备 磁盘--存储
- 字符设备 终端/打印机--输入输出

- 独占 共享 虚拟 （spooling

四种驱动方式

- 程序轮询：实现简单，效率极低

- 中断驱动：适用字符设备

  - CPU 发出 I/O 命令后 **不再等待**

    设备准备好后，**向 CPU 发送中断信号**

    CPU 响应中断，短暂进入中断处理程序完成数据传输（传输前中断）

- DMA驱动：适用块设备 绕过CPU

  - **数据直接从设备到内存（或反向）传输，不经 CPU**

    CPU 只在 **开始时发出指令**，和 **完成时收到中断**（传输完成中断）

    传输由 DMA 控制器（硬件）完成

- 通道控制：高级复杂昂贵，适用大型系统

硬件：IO控制器

软件：IO驱动程序

- 必须用汇编语言
- 一个程序可控制多个同类设备

设备独立性：映射逻辑与物理名称

:bulb: 5.4.2 缓冲 单双​

缓冲池概念与操作 

理解5.5

---

## 文件管理

:bulb:文件系统

:bulb:6.2.2 链接文件 多级索引 引入前后检索效率

- 连续文件：适应于顺序存取且文件不经常修改的情况
- 链接文件。
  - 隐式链接。上一块最后放下一块地址，可用空间-1。
  - FAT表，与链表类似，空间利用率高，便于顺序访问与修改，但随机存取效率低，占内存。
    - FAT表大小计算：盘块号大小取半字节整数倍
- 索引文件：既适应于顺序访问，也适应于随机访问 但要有用于索引表的空间开销和文件索引的时间开销。
  - 混合索引，10个一级，1二级1三级
  - 计算最大文件和最大可管理磁盘空间

:bulb: 目录检索 

- FCB：包含一系列琐碎信息
- 发现检索实际只需用户名，于是引入索引节点inode，目录项只存放用户名与inode编号，具体琐碎信息再根据编号去查找inode，减轻检索时的数据负担。
- inode 存放在磁盘，打开文件时读取到内存，增加状态、链接等信息

- 访问磁盘次数

:bulb: 文件存储空间管理 位示图 成组链接

- 空闲表法
- 空闲块链表法。需顺序访问，慢。
- 位示图法。精确查找、支持并发；占用内存大，访问慢。
- 成组链接法。每组设1控制块，存储本组可用块数与下组目录

:bulb:共享方式

- 基于inode实现硬链接，共享inode，文件属性正常，不能跨卷，不能共享目录。
- 符号链接：新建inode，是大小不同的新文件，但存的是路径，文件属性是共享link。不影响原文件被引用次数

保护方式：设权限WRX/设密令/加密

:bulb:6.6 磁盘管理

- 存储容量=磁头数×磁道(柱面)数×每道扇区数×每扇区字节数
- 访问时间=寻道时间+旋转延迟时间+传输时间（例题）

饥饿：某些进程始终被阻塞

磁盘调度 ：移臂调度减少寻道时间/旋转调度减少旋转时间

移臂调度：

- FCFS 
- SSTF 最短优先
- SCAN （电梯），先单向 ：3-5-7-2-1
- CSCAN 完全单向 ：3-5-7-1-2
- N-Step-SCAN 按顺序分组再scan（多个长度为N的子队列）
- FSCAN，当前先处理，后来单独排队（两个子队列）

旋转调度：先移臂，再同一柱面选盘面最近的，使旋转周数最少

先排柱面，再排同柱面磁头，最后排同磁头块号



:bulb: 综合题 文件读取：查表找块号--逐块读磁盘--计算总时间

---

思政题 国产系统

1.甲、乙、丙三人合作种树，首先甲负责挖树坑：然后乙负责放树苗、填土，最后丙负责浇水。只有一把铁锹和一个水桶，甲挖坑当且仅当树坑<3时才挖坑，挖坑和填土需要铁锹，浇水需要水桶。请用尽可能少的信号量和 wait （）、signal （）操作，实现三人之间的互斥和其他关系

```
// 初始化
semaphore mutex_shovel = 1;
semaphore hole_sem = 0;    // 甲 -> 乙
semaphore tree_sem = 0;    // 乙 -> 丙
semaphore space_sem = 3;   // 最多允许3个坑

while (true) {
    wait(space_sem);        // 等待有坑位
    wait(mutex_shovel);     // 占用铁锹
    // 挖坑
    signal(mutex_shovel);   // 释放铁锹
    signal(hole_sem);       // 通知乙有新坑
}

while (true) {
    wait(hole_sem);         // 等待甲挖坑完成
    wait(mutex_shovel);     // 占用铁锹
    // 放苗并填土
    signal(mutex_shovel);   // 释放铁锹
		signal(space_sem);      // 释放坑位    
		signal(tree_sem);       // 通知丙可浇水
}

while (true) {
    wait(tree_sem);         // 等待乙填土完成
    // 浇水

}
```

|           操作系统内核区           |
| :--------------------------------: |
|        用户栈 （局部变量）         |
|         共享库的存储映射区         |
| 动志生成的堆（运行时由malloc创建） |
|      读/写数据段（全局变量）       |
|             只读代码段             |
|              未使用区              |



（1） 代码执行时，PCB位于图中哪个位置？执行scanf（）函数时，进程处于什么状态？

- 内核区 阻塞

（2）代码中的 main（）、ptr 指针、length 变量和 malloc 函数各位于右图中哪个位置

- 代码段 数据段 用户栈 共享库

（3） 代码中哪些函数会调用 I/O 驱动程序？

- scanf printf

---

用户发起程序执行请求
    ↓
系统创建进程控制块（PCB）
    ↓
分配虚拟地址空间（逻辑分区）
    ↓
建立页表、栈、堆等信息
    ↓
装入部分代码页/数据页到物理内存（按需）
    ↓
程序开始运行



- 进程状态转换
- 存储器管理：